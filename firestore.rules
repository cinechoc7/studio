/**
 * @fileoverview Firestore Security Rules for the package tracking application.
 *
 * Core Philosophy:
 * This ruleset implements a role-based access control system with admin privileges and ownership-based restrictions for packages.
 * Anonymous users can read package information.
 *
 * Data Structure:
 * - /packages/{packageId}: Stores package information, including adminId for authorization.
 * - /package_statuses/{packageStatusId}: Stores package status updates.
 * - /customers/{customerId}: Stores customer information.
 * - /admins/{adminId}: Stores admin user information.
 * - /delivery_route_plans/{deliveryRoutePlanId}: Stores delivery route plans.
 * - /roles_admin/{uid}: A document's existence in this collection signifies admin role.
 *
 * Key Security Decisions:
 * - Admins can create, update, and delete packages assigned to them (enforced via adminId).
 * - Package statuses and delivery route plans are publicly readable.
 * - Customer and admin information is only accessible to authenticated users who own the respective documents.
 * - The 'roles_admin' collection determines admin status based on document existence.
 *
 * Denormalization for Authorization:
 * - The `packages` collection contains the `adminId` field, which indicates the administrator responsible for a particular package. This denormalization enables security rules that directly check if the currently authenticated user (`request.auth.uid`) matches the `adminId` without needing to perform a `get()` request to another document. This ensures that authorization checks are atomic and efficient.
 *
 * Structural Segregation:
 * - The 'roles_admin' collection is used to segregate admin role data, enabling efficient role checking via `exists()` in security rules without exposing sensitive user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     * @example isSignedIn() == true
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is an admin based on the existence of their UID in the `/roles_admin/{uid}` collection.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId - The user ID to check against the request's auth UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     * @example isOwner('someUserId') == true
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource and that the resource exists.
     * @param {string} userId - The user ID to check against the resource's userId and the request's auth UID.
     * @return {boolean} True if the user is the owner and resource exists, false otherwise.
     * @example isExistingOwner('someUserId') == true
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

   /**
     * @description Rules for the /packages/{packageId} collection.
     * @path /packages/{packageId}
     * @allow (create) - An admin can create a package if the request.resource.data.adminId matches their UID. Example: auth.uid = 'admin123', request.resource.data.adminId = 'admin123'
     * @allow (update) - An admin can update a package if they are the assigned admin (resource.data.adminId matches their UID). Example: auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @allow (delete) - An admin can delete a package if they are the assigned admin (resource.data.adminId matches their UID) and the package exists. Example: auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @allow (get) - Any user can read a package.
     * @allow (list) - Any user can list packages.
     * @deny (create) - A non-admin user attempts to create a package. Example: auth.uid = 'user123', request.resource.data.adminId = 'admin456'
     * @deny (update) - A user attempts to update a package they are not assigned to. Example: auth.uid = 'user123', resource.data.adminId = 'admin456'
     * @deny (delete) - A user attempts to delete a package they are not assigned to. Example: auth.uid = 'user123', resource.data.adminId = 'admin456'
     * @principle Enforces admin-ownership for writes; public reads for package data.
     */
    match /packages/{packageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update: if isSignedIn() && isAdmin() && isExistingOwner(resource.data.adminId);
      allow delete: if isSignedIn() && isAdmin() && isExistingOwner(resource.data.adminId);
    }

    /**
     * @description Rules for the /package_statuses/{packageStatusId} collection.
     * @path /package_statuses/{packageStatusId}
     * @allow (get) - Any user can read a package status.
     * @allow (list) - Any user can list package statuses.
     * @allow (create) - No one can create a package status.
     * @allow (update) - No one can update a package status.
     * @allow (delete) - No one can delete a package status.
     * @principle Allows public read access to package statuses.
     */
    match /package_statuses/{packageStatusId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /customers/{customerId} collection.
     * @path /customers/{customerId}
     * @allow (create) - A user can create their own customer document (customerId matches auth.uid).
     * @allow (get) - A user can read their own customer document (customerId matches auth.uid).
     * @allow (list) - A user can list their own customer documents (customerId matches auth.uid).
     * @allow (update) - A user can update their own customer document (customerId matches auth.uid). The customer document must already exists.
     * @allow (delete) - A user can delete their own customer document (customerId matches auth.uid) and the customer document must already exists.
     * @deny (create) - A user attempts to create a customer document with a different customerId.
     * @deny (get) - A user attempts to read another user's customer document.
     * @deny (list) - A user attempts to list other user's customer documents.
     * @deny (update) - A user attempts to update another user's customer document.
     * @deny (delete) - A user attempts to delete another user's customer document.
     * @principle Enforces document ownership for customer data.
     */
    match /customers/{customerId} {
      allow get, list: if isOwner(customerId);
      allow create: if isOwner(customerId);
      allow update: if isExistingOwner(customerId);
      allow delete: if isExistingOwner(customerId);
    }

    /**
     * @description Rules for the /admins/{adminId} collection.
     * @path /admins/{adminId}
     * @allow (create) - A user can create their own admin document (adminId matches auth.uid).
     * @allow (get) - A user can read their own admin document (adminId matches auth.uid).
     * @allow (list) - A user can list their own admin documents (adminId matches auth.uid).
     * @allow (update) - A user can update their own admin document (adminId matches auth.uid). The admin document must already exists.
     * @allow (delete) - A user can delete their own admin document (adminId matches auth.uid) and the admin document must already exists.
     * @deny (create) - A user attempts to create an admin document with a different adminId.
     * @deny (get) - A user attempts to read another user's admin document.
     * @deny (list) - A user attempts to list other user's admin documents.
     * @deny (update) - A user attempts to update another user's admin document.
     * @deny (delete) - A user attempts to delete another user's admin document.
     * @principle Enforces document ownership for admin data.
     */
    match /admins/{adminId} {
      allow get, list: if isOwner(adminId);
      allow create: if isOwner(adminId);
      allow update: if isExistingOwner(adminId);
      allow delete: if isExistingOwner(adminId);
    }

    /**
     * @description Rules for the /delivery_route_plans/{deliveryRoutePlanId} collection.
     * @path /delivery_route_plans/{deliveryRoutePlanId}
     * @allow (get) - Any user can read a delivery route plan.
     * @allow (list) - Any user can list delivery route plans.
     * @allow (create) - No one can create a delivery route plan.
     * @allow (update) - No one can update a delivery route plan.
     * @allow (delete) - No one can delete a delivery route plan.
     * @principle Allows public read access to delivery route plans.
     */
    match /delivery_route_plans/{deliveryRoutePlanId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

      /**
     * @description Rules for the /roles_admin/{uid} collection. A document's existence in this collection grants admin role.
     * @path /roles_admin/{uid}
     * @allow (get) - Admin users can read the document, other users cannot.
     * @allow (list) - Admin users can list the document, other users cannot.
     * @allow (create) - Admin users can create the document, other users cannot.
     * @allow (update) - Admin users can update the document, other users cannot. The document must already exists.
     * @allow (delete) - Admin users can delete the document, other users cannot. The document must already exists.
     * @principle Only admin can write in the `/roles_admin/{uid}` collection.
     */
    match /roles_admin/{uid} {
      allow get, list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}